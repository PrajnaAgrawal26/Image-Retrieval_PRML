# -*- coding: utf-8 -*-
"""Kmeans.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pu2KKhTbXZeGY7c07cFCqmAydvTuLRk0

#**CNN+ LDA+ KMEANS**
"""

import numpy as np
import torch
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
from torchvision import models
from sklearn.cluster import KMeans
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA
import pickle
from tqdm import tqdm
from collections import defaultdict

# Define device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")


classes = ['airplane', 'automobile', 'bird', 'cat', 'deer',                     #CIFAR-10 class list
           'dog', 'frog', 'horse', 'ship', 'truck']


transform = transforms.Compose([                                                #Image transformation
    transforms.Resize((224, 224)),                                              #Resize images to 224x224, convert to tensor, and normalize using ImageNet stats
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406],
                         std=[0.229, 0.224, 0.225])
])

trainset = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=64, shuffle=False, num_workers=2)


resnet50 = models.resnet50(weights=models.ResNet50_Weights.DEFAULT)             #Load ResNet50 model with feature extractor
resnet50.fc = nn.Identity()                                                     #Remove final classification layer
resnet50 = resnet50.to(device)
resnet50.eval()


cnn_features = []                                                               #Store extracted CNN features and corresponding labels
labels = []

                                                                                #Extract normalized CNN features from images
with torch.no_grad():
    for images, targets in tqdm(trainloader, desc="Extracting CNN Features"):
        images = images.to(device)
        feats = resnet50(images)                                                #Get ResNet features
        feats = feats / feats.norm(dim=1, keepdim=True)                         #L2 normalize features
        cnn_features.append(feats.cpu().numpy())                                #Move to CPU and convert to NumPy
        labels.append(targets.numpy())

                                                                                #Concatenate all extracted features and labels
x_train_cnn = np.concatenate(cnn_features, axis=0)
y_train = np.concatenate(labels, axis=0)
print("Extracted feature shape:", x_train_cnn.shape)

                                                                                #Apply Linear Discriminant Analysis (LDA) for dimensionality reduction
lda = LDA(n_components=9)                                                       #Reduce to (number of classes - 1) dimensions
x_train_lda = lda.fit_transform(x_train_cnn, y_train)

                                                                                #Apply KMeans clustering on reduced features
kmeans = KMeans(n_clusters=10, random_state=42, n_init=50)                      #10 clusters for 10 CIFAR-10 classes
clusters = kmeans.fit_predict(x_train_lda)

                                                                                #Map each KMeans cluster to a CIFAR-10 class using majority vote
label_map = {}
for i in range(10):
    indices = np.where(clusters == i)[0]                                        #Get indices of samples in cluster i
    true_labels = y_train[indices]                                              #Get their true labels
    if len(true_labels) > 0:
        label_map[i] = np.bincount(true_labels).argmax()                        #Assign most frequent label in cluster


print("Label Map:", label_map)

from sklearn.metrics import accuracy_score, classification_report


# Load CIFAR-10 test dataset
testset = torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform)
testloader = torch.utils.data.DataLoader(testset, batch_size=64, shuffle=False, num_workers=2)

# Extract CNN features for test set
test_features = []
test_labels = []

with torch.no_grad():
    for images, targets in tqdm(testloader, desc="Extracting Test CNN Features"):
        images = images.to(device)
        feats = resnet50(images)
        feats = feats / feats.norm(dim=1, keepdim=True)
        test_features.append(feats.cpu().numpy())
        test_labels.append(targets.numpy())

x_test_cnn = np.concatenate(test_features, axis=0)
y_test = np.concatenate(test_labels, axis=0)

# Apply LDA transformation on test features
x_test_lda = lda.transform(x_test_cnn)

# Predict test clusters and map to CIFAR-10 labels
test_preds_cluster = kmeans.predict(x_test_lda)
test_preds = np.array([label_map[cluster] for cluster in test_preds_cluster])

# Test Classification Report
print("\nTest Classification Report:")
print(classification_report(y_test, test_preds, target_names=classes))

import pickle                                                                   #save the model pipeline
pipeline = {
    'lda': lda,
    'kmeans': kmeans,
    'label_map': label_map,
    'resnet': 'resnet50 with fc=Identity and normalized features'
}

with open("kmeans+lda+cnn.pkl", "wb") as f:
    pickle.dump(pipeline, f)

print("Saved as 'kmeans+lda+cnn.pkl'")